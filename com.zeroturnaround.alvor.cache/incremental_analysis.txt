Interesting things a file can contain:
---------------------------------------
* calls to fixed hotspot patterns
* calls to wrapper (deduced) hotspot patterns
* definitions of new (deduced) hotspot patterns (ie. methods, which call to some hotspot-pattern,
  but take part of the input from parameters)
* overridden hotspot patterns

* string methods which are used in some hotspot expression
* overridden versions of such string methods

Of these, other files depend on:
	- definitions of new (possibly partial) hotspot patterns (need to search for calls to these)
	- overriding implementations of used string methods (can be just added to cache and to 
	  corresponding string-choices) 
    	


After edit, (or after choosing next file during initial checking) 
--------------------------------------------
Tasks concerning hotspots:
	* remove from cache all hotspot-patterns introduced by this file 
	  (because those methods may not be hotspots anymore)
		- leave corresponding strings in place, in case it's still a hotspot
		- or maybe just mark its hotspot-definitions as questionable
		
	* parse the file and search for calls to (remaining) hotspot-patterns
	  and evaluate those (without going out from current file (leave stubs in cache) ?)
	    - in this process its hotspot-patterns may be restored
	     
	* remove from cache all questionable hotspot-patterns from this file, together with the strings
	 
* add new hotspots to table (and search their call-sites)


?? Should I recurse to other files, when string has parts outside this file?
   Or leave the stubs in cache and wait until those files are processed and stubs are filled in ??
?? During recursing, should I search only for requested call-sites, or start processing that file?   


Handling virtual methods
------------------------
Short story: all known method overrides are considered always  

* when I need to get something from parameter, then I search calls not only to this particular
  (possibly overridden) method but also calls where receiver is supertype of 'this'.
* In cache, all (partial or full) hotspot methods are registered by the name of the class/interface
  where the method was first introduced.

* when I need result of a string method, then I look up it's uppermost declaration type and
  then combine implementations from all overrides. (Yes, this can lose precision)   
* In cache, string methods are registered using

* Other option -- first time when a set of call-sites or implementations are required,
  then all are registered (in a separate table), but when constructing the string-choice, static type of the 
  receiver is taken into account


Deleting and creating file
---------------------------
Deleting can be considered as edit which makes file/classdef empty
Likewise, creating new file adds stuff to empty file/classdef. 
