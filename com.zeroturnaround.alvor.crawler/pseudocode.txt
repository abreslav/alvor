First read the tool-paper.

Definitions
-----------
TODO

Simple explanation
------------------
Alvor searches for all hotspots in all project files
For each matching string node, it constructs the set of it's possible values. For this, 
it may be necessary to analyze relevant parts in other files.

Interesting things a file can contain:
---------------------------------------
* calls to fixed hotspot patterns
* calls to wrapper (deduced) hotspot patterns
* definitions of new (deduced) hotspot patterns (ie. methods, which call to some hotspot-pattern,
  but take part of the input from parameters)
* overridden hotspot patterns

* string methods which are used in some hotspot expression
* overridden versions of such string methods

Of these, other files depend on:
	- definitions of new (possibly partial) hotspot patterns (need to search for calls to these)
	- overriding implementations of used string methods (can be just added to cache and to 
	  corresponding string-choices) 
    	


Incremental checking
--------------------
In order to enable incremental checking, Alvor stores certain information about each file
in a database. When one file is changed, then cache for that file is discarded and the
file is analyzed (almost) from scratch. When some parts are required from other files,
then these can now be taken from cache.


Pseudocode
----------

fun fullCheckProject(project, conf) = 
	files = project.getFiles()
	hotspots = conf.fixedHotspots
	strings = findStringsFromManyFilesForManyHotspots(files, hotspots, project)
	check(strings)


fun checkFileAfterEdit(file, project, conf) = 
	cache.removeFileEntries(file)  // marks dependent strings as unchecked
	hotspots = conf.fixedHotspots ++ cache.getSecondaryHotspots
	strings1 = findStringsFromOneFileForManyHotspots(file, hotspots)
	check(strings1)
	
	// some base Hotspot entries from other files now got modified and need to be rechecked 
	strings2 = cache.getUncheckedStrings()
	check(strings2) 

fun findStringsFromManyFilesForManyHotspots(files, hotspots) =
	result = [] 
	for file <- files:
		result.addAll(findStringsFromOneFileForManyHotspots(file, hotspots))
		
	return result
	
fun findStringsFromOneFileForManyHotspots(file, hotspots) =
	result = []
	hotspotsToBeSearched = []
	 
	for hotspot <- hotspots:
	    if cache.hasEntryFor(file, hotspot):
	        result.addAll(getFromCache(file, hotspot))
	    else:
	    	hotspotsToBeSearched.add(hotspot)
	
	
	for node <- findCorrespondingNodes(file, hotspotsToBeSearched):
		str = evaluate(node)
	    result.add(str)
	    cache.addEntryFor(str, file, hotspot) // marks dependent strings as unchecked
	
	return result

fun evaluate(node, project) =
	// this doesn't use cache (directly)
    ...
    if node is Parameter:
    	files = project.getAllFiles()
    	return findStringsFromManyFilesForManyHotspots(files, [node as hotspot])
    
    ...