First read the tool-paper.

Simple explanation
------------------
Alvor searches for all primary hotspots in all project files
For each matching string expression, it constructs the set of it's possible values. For this, 
it may be necessary to analyze relevant parts in other files.

Interesting things a file can contain:
---------------------------------------
* primary hotspots
* secondary hotspots
* primary hotspot targets, ie. target methods for primary hotspots
* secondary hotspot targets (or "hotspot wrappers") -- ie. methods containing 
  hotspots whose value is (partly) taken from a parameter
  
* overridden hotspot targets (primary or secondary)

* relevant string methods (string methods which are used for constructing value of a hotspot)
* overridden versions of such string methods

Checking one file
-----------------
From given file we want abstract values of primary hotspots. For this it might be
necessary to analyze other files if hotspot value depends on method argument (need to find
and analyze secondary hotspots).

Incremental checking
--------------------
In order to enable incremental checking, Alvor stores certain information about each file
in a database. When one file is changed, then cache for that file is discarded and the
file is analyzed (almost) from scratch. When some parts are required from other files,
then these can now be taken from cache.

When one file is changed, then in addition to reanalyzing primary hotspots in this file,
we need also to take care of hotspots in other files depending on that file. 
In order to do this, inter-file dependencies for each primary hotspot must be published
by registering respective secondary hotspot patterns.
Whenever a file is changed then both primary and secondary patterns are searched and analyzed
in it.

Likewise, all "relevant string methods" must be published, so that when a file containing
an implementation of such method is changed, then cached information about this method
can be updated (even when that method is not used in the same file).

As one project may be dependent of other projects, when a library project is changed, then
analysis must take into account registered secondary patterns (and string methods) from all
dependent projects. Pattern registration is organized per-project basis.


Pseudocode
----------

fun fullCheckProject(project, conf) = 
	files = project.getFiles()
	hotspots = conf.fixedHotspots
	strings = findStringsFromManyFilesForManyHotspots(files, hotspots, project)
	check(strings)


fun checkFileAfterEdit(file, project, conf) = 
	cache.removeFileEntries(file)  // marks dependent strings as unchecked
	hotspots = conf.fixedHotspots ++ cache.getSecondaryHotspots
	strings1 = findStringsFromOneFileForManyHotspots(file, hotspots)
	check(strings1)
	
	// some base Hotspot entries from other files now got modified and need to be rechecked 
	strings2 = cache.getUncheckedStrings()
	check(strings2) 

fun findStringsFromManyFilesForManyHotspots(files, hotspots) =
	result = [] 
	for file <- files:
		result.addAll(findStringsFromOneFileForManyHotspots(file, hotspots))
		
	return result
	
fun findStringsFromOneFileForManyHotspots(file, hotspots) =
	result = []
	hotspotsToBeSearched = []
	 
	for hotspot <- hotspots:
	    if cache.hasEntryFor(file, hotspot):
	        result.addAll(getFromCache(file, hotspot))
	    else:
	    	hotspotsToBeSearched.add(hotspot)
	
	
	for node <- findCorrespondingNodes(file, hotspotsToBeSearched):
		str = evaluate(node)
	    result.add(str)
	    cache.addEntryFor(str, file, hotspot) // marks dependent strings as unchecked
	
	return result

fun evaluate(node, project) =
	// this doesn't use cache (directly)
    ...
    if node is Parameter:
    	files = project.getAllFiles()
    	return findStringsFromManyFilesForManyHotspots(files, [node as hotspot])
    
    ...
    
------------------------------------------------------------------------------------------

Partial checking
----------------
If certain IJavaElement is selected for checking, then this part is searched only for primary
hotspots. If it contains secondary hotspots, then those are analyzed only when respective
primary hotspots are also within search/analysis scope.

Secondary hotspots are searched in the same project.

Implementations of string-methods are searched from all required projects.